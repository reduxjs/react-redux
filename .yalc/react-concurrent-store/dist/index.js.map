{"version":3,"sources":["../src/experimental/index.ts","../src/experimental/useStore.tsx","../src/experimental/Store.ts","../src/experimental/Emitter.ts","../src/experimental/StoreManager.ts","../src/useStore.ts","../src/types.ts","../src/index.ts"],"sourcesContent":["export {\r\n  useStore,\r\n  useStoreSelector,\r\n  createStore,\r\n  createStoreFromSource,\r\n  StoreProvider,\r\n} from \"./useStore\";\r\n\r\n// Export types needed for public API\r\nexport type { ISource, Reducer } from \"../types\";\r\nexport { Store } from \"./Store\";","import * as React from \"react\";\r\nimport {\r\n  createContext,\r\n  memo,\r\n  startTransition,\r\n  useContext,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useRef,\r\n  useState,\r\n} from \"react\";\r\nimport { Store } from \"./Store\";\r\nimport { ISource, Reducer } from \"../types\";\r\nimport { StoreManager } from \"./StoreManager\";\r\n\r\n/**\r\n * Concurrent-Safe Store\r\n *\r\n * The store and a associated hook ensures that when new store readers mount,\r\n * they will observe the same state as all other components currently mounted,\r\n * even if the store's state is currently updating within a slow transition.\r\n *\r\n * They further ensure that React's rebasing rules apply to state observed via\r\n * these hooks. Specifically, updates always apply in the order in chronological\r\n * order. This means that if a sync update to the store is triggered while a\r\n * transition update to the store is still pending that sync update will apply\r\n * on top of the pre-transition state (as if the transition update had not yet\r\n * happened), but when the transition resolves it will reflect the chronological\r\n * ordering of: initial, transition, sync.\r\n *\r\n * Note: Rather than expose generic versions of these hooks/providers and have them\r\n * read the store via context, we use a factory function which returns pre-bound\r\n * functions. This has the advantage of producing typed variants of the hooks.\r\n *\r\n * A more standard context based solution should also be possible.\r\n */\r\nexport function createStore<S, A>(\r\n  reducer: Reducer<S, A>,\r\n  initialState: S,\r\n): Store<S, A> & { dispatch: (action: A) => void } {\r\n  let state = initialState;\r\n  const store = new Store<S, A>({\r\n    getState: () => state,\r\n    reducer,\r\n  });\r\n\r\n  // @ts-expect-error TODO: Fix typing\r\n  store.dispatch = (action: A) => {\r\n    state = reducer(state, action);\r\n    store.handleUpdate(action);\r\n  };\r\n  // @ts-expect-error TODO: Fix typing\r\n  return store;\r\n}\r\n\r\nexport function createStoreFromSource<S, A>(\r\n  source: ISource<S, A>,\r\n): Store<S, A> {\r\n  return new Store<S, A>(source);\r\n}\r\n\r\nconst storeManagerContext = createContext<StoreManager | null>(null);\r\n\r\n/**\r\n * An awkward kludge which attempts to signal back to the stores when a\r\n * transition containing store updates has been committed to the React tree.\r\n */\r\nconst CommitTracker = memo(\r\n  ({ storeManager }: { storeManager: StoreManager }) => {\r\n    const [allStates, setAllStates] = useState(\r\n      storeManager.getAllCommittedStates(),\r\n    );\r\n    useEffect(() => {\r\n      const unsubscribe = storeManager.subscribe(() => {\r\n        const allStates = storeManager.getAllStates();\r\n        setAllStates(allStates);\r\n      });\r\n      return () => {\r\n        unsubscribe();\r\n        storeManager.sweep();\r\n      };\r\n    }, [storeManager]);\r\n\r\n    useLayoutEffect(() => {\r\n      storeManager.commitAllStates(allStates);\r\n    }, [storeManager, allStates]);\r\n    return null;\r\n  },\r\n);\r\n\r\n/**\r\n * A single provider which tracks commits for all stores being read in the tree.\r\n */\r\nexport function StoreProvider({ children }: { children: React.ReactNode }) {\r\n  const [storeManager] = useState(() => new StoreManager());\r\n  return (\r\n    <storeManagerContext.Provider value={storeManager}>\r\n      <CommitTracker storeManager={storeManager} />\r\n      {children}\r\n    </storeManagerContext.Provider>\r\n  );\r\n}\r\n\r\n/**\r\n * Tearing-resistant hook for consuming application state locally within a\r\n * component (without prop drilling or putting state in context).\r\n *\r\n * Attempts to avoid the failure mode where the application state is updating as\r\n * part of a transition and a sync state change causes a new component to mount\r\n * that reads the application state.\r\n *\r\n * A naive implementation which simply subscribes to state changes in a useEffect\r\n * would incorrectly mount using the pending state causing tearing between the\r\n * newly mounted component (showing the new state) and the previously mounted\r\n * components which would still be showing the old state.\r\n *\r\n * A slightly more sophisticated approach which mounts with the currently\r\n * committed state would suffer from permanent tearing since the mount state\r\n * would not update to the pending state along with the rest of the\r\n * pending transition.\r\n *\r\n * This approach mounts with the currently committed state and then, if needed\r\n * schedules a \"fixup\" update inside a transition to ensure the newly mounted\r\n * component updates along with any other components that are part of the\r\n * current pending transition.\r\n *\r\n * This implementation also attempts to solve for a non-concurrent race\r\n * condition where state updates between initial render and when the\r\n * `useEffect` mounts. e.g. in the `useEffect` of another component that gets\r\n * mounted before this one. Here the risk is that we miss the update, since we\r\n * are not subscribed yet, and end up rendering the stale state with no update\r\n * scheduled to catch us up with the rest of the app.\r\n */\r\nexport function useStoreSelector<S, T>(\r\n  store: Store<S, any>,\r\n  selector: (state: S) => T,\r\n): T {\r\n  const storeManager = useContext(storeManagerContext);\r\n  if (storeManager == null) {\r\n    throw new Error(\r\n      \"Expected useStoreSelector to be rendered within a StoreProvider.\",\r\n    );\r\n  }\r\n  const previousStoreRef = useRef(store);\r\n  if (store !== previousStoreRef.current) {\r\n    throw new Error(\r\n      \"useStoreSelector does not currently support dynamic stores\",\r\n    );\r\n  }\r\n  const previousSelectorRef = useRef(selector);\r\n  if (selector !== previousSelectorRef.current) {\r\n    throw new Error(\r\n      \"useStoreSelector does not currently support dynamic selectors\",\r\n    );\r\n  }\r\n\r\n  // Counterintuitively we initially render with the transition/head state\r\n  // instead of the committed state. This is required in order for us to\r\n  // handle the case where we mount as part of a transition which is actively\r\n  // changing the state we observe. In that case, if we _don't_ mount with the\r\n  // transition state, there's no place where we can schedule a fixup which\r\n  // will get entangled with the transition that is rendering us. React forces\r\n  // all setStates fired during render into their own lane, and by the time\r\n  // our useLayoutEffect fires, the transition will already be completed.\r\n  //\r\n  // Instead we must initially render with the transition state and then\r\n  // trigger a sync fixup setState in the useLayoutEffect if we are mounting\r\n  // sync and thus should be showing the committed state.\r\n  const [state, setState] = useState<T>(() => selector(store.getState()));\r\n\r\n  useLayoutEffect(() => {\r\n    // Ensure our store is managed by the tracker.\r\n    storeManager.addStore(store);\r\n    const mountState = selector(store.getState());\r\n    const mountCommittedState = selector(store.getCommittedState());\r\n\r\n    // If we are mounting as part of a sync update mid transition, our initial\r\n    // render value was wrong and we must trigger a sync fixup update.\r\n    // Similarly, if a sync state update was triggered between the moment we\r\n    // rendered and now (e.g. in some sibling component's useLayoutEffect) we\r\n    // need to trigger a fixup.\r\n    //\r\n    // Both of these cases manifest as our initial render state not matching\r\n    // the currently committed state.\r\n    if (state !== mountCommittedState) {\r\n      setState(mountCommittedState);\r\n    }\r\n\r\n    // If we mounted mid-transition, and that transition is still ongoing, we\r\n    // mounted with the pre-transition state but are not ourselves part of the\r\n    // transition. We must ensure we update to the new state along with the\r\n    // rest of the UI when the transition resolves\r\n    if (mountState !== mountCommittedState) {\r\n      // Here we tell React to update us to the new pending state. Since all\r\n      // state updates are propagated to React components in transitions, we\r\n      // assume there is a transition currently happening, and (unsafely)\r\n      // depend upon current transition entanglement semantics which we expect\r\n      // will ensure this update gets added to the currently pending\r\n      // transition. Our goal is that when the transition that was pending\r\n      // while we were mounting resolves, it will also include rerendering\r\n      // this component to reflect the new state.\r\n      startTransition(() => {\r\n        setState(mountState);\r\n      });\r\n    }\r\n    const unsubscribe = store.subscribe(() => {\r\n      const state = store.getState();\r\n      setState(selector(state));\r\n    });\r\n    return () => {\r\n      unsubscribe();\r\n      storeManager.removeStore(store);\r\n    };\r\n    // We intentionally ignore `state` since we only care about its value on mount\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  return state;\r\n}\r\n\r\nfunction identity<T>(x: T): T {\r\n  return x;\r\n}\r\n\r\nexport function useStore<S>(store: Store<S, any>): S {\r\n  return useStoreSelector(store, identity);\r\n}\r\n","import * as React from \"react\";\r\nimport { startTransition } from \"react\";\r\nimport { ISource } from \"../types\";\r\nimport Emitter from \"./Emitter\";\r\n\r\nconst sharedReactInternals: { T: unknown } =\r\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE as any;\r\n\r\nfunction reactTransitionIsActive() {\r\n  return !!sharedReactInternals.T;\r\n}\r\n\r\nexport class Store<S, A> extends Emitter<[]> {\r\n  public source: ISource<S, A>;\r\n  public state: S;\r\n  public committedState: S;\r\n  constructor(source: ISource<S, A>) {\r\n    super();\r\n    this.source = source;\r\n    this.state = source.getState();\r\n    this.committedState = source.getState();\r\n  }\r\n\r\n  commit(state: S) {\r\n    this.committedState = state;\r\n  }\r\n  getCommittedState(): S {\r\n    return this.committedState;\r\n  }\r\n  getState(): S {\r\n    return this.state;\r\n  }\r\n  handleUpdate(action: A) {\r\n    const noPendingTransitions = this.committedState === this.state;\r\n\r\n    this.state = this.source.getState();\r\n\r\n    if (reactTransitionIsActive()) {\r\n      // For transition updates, everything is simple. Just notify all readers\r\n      // of the new state.\r\n      this.notify();\r\n    } else {\r\n      // For sync updates, we must consider if we need to juggle multiple state\r\n      // updates.\r\n\r\n      // If there are no pending transition updates, things are very similar to\r\n      // a transition update except that we can proactively mark the new state\r\n      // as committed.\r\n      if (noPendingTransitions) {\r\n        this.committedState = this.state;\r\n        this.notify();\r\n      } else {\r\n        // If there are pending transition updates, we must ensure we compute\r\n        // an additional new states: This update applied on top of the current\r\n        // committed state.\r\n\r\n        const newState = this.state;\r\n\r\n        // React's rebasing semantics mean readers will expect to see this\r\n        // update applied on top of the currently committed state sync.\r\n        this.committedState = this.source.reducer(this.committedState, action);\r\n        // Temporarily set the state so that readers during this notify read the\r\n        // new committed state.\r\n        this.state = this.committedState;\r\n        this.notify();\r\n\r\n        // Now that we've triggered the sync updates, we need to ensure the\r\n        // pending transition update now goes to the correct new state. We reset\r\n        // the state to point to the new transition state and trigger a set of\r\n        // updates inside a transition.\r\n\r\n        // With existing transition semantics this should result in these\r\n        // updates entangling with the previous transition and that transition\r\n        // will now include this state instead of the previously pending state.\r\n        this.state = newState;\r\n        startTransition(() => {\r\n          this.notify();\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n","export default class Emitter<T extends Array<unknown>> {\r\n  _listeners: Array<(...value: T) => void> = [];\r\n  subscribe(cb: (...value: T) => void): () => void {\r\n    const wrapped = (...value: T) => cb(...value);\r\n    this._listeners.push(wrapped);\r\n    return () => {\r\n      this._listeners = this._listeners.filter((s) => s !== wrapped);\r\n    };\r\n  }\r\n  notify(...value: T) {\r\n    this._listeners.forEach((cb) => {\r\n      cb(...value);\r\n    });\r\n  }\r\n}\r\n","import Emitter from \"./Emitter\";\r\nimport { Store } from \"./Store\";\r\n\r\ntype RefCountedSubscription = {\r\n  count: number;\r\n  unsubscribe: () => void;\r\n};\r\n\r\ntype StoresSnapshot = Map<Store<unknown, unknown>, unknown>;\r\n\r\n/**\r\n * StoreManager tracks all actively rendered stores in the tree and maintains a\r\n * reference-counted subscription to each one. This allows the <CommitTracker />\r\n * component to observe every state update and record each store's committed\r\n * state.\r\n */\r\nexport class StoreManager extends Emitter<[]> {\r\n  _storeRefCounts: Map<Store<unknown, unknown>, RefCountedSubscription> =\r\n    new Map();\r\n\r\n  getAllCommittedStates(): StoresSnapshot {\r\n    return new Map(\r\n      Array.from(this._storeRefCounts.keys()).map((store) => [\r\n        store,\r\n        store.getCommittedState(),\r\n      ]),\r\n    );\r\n  }\r\n\r\n  getAllStates(): StoresSnapshot {\r\n    return new Map(\r\n      Array.from(this._storeRefCounts.keys()).map((store) => [\r\n        store,\r\n        store.getState(),\r\n      ]),\r\n    );\r\n  }\r\n\r\n  addStore(store: Store<any, any>) {\r\n    const prev = this._storeRefCounts.get(store);\r\n    if (prev == null) {\r\n      this._storeRefCounts.set(store, {\r\n        unsubscribe: store.subscribe(() => {\r\n          this.notify();\r\n        }),\r\n        count: 1,\r\n      });\r\n    } else {\r\n      this._storeRefCounts.set(store, { ...prev, count: prev.count + 1 });\r\n    }\r\n  }\r\n\r\n  commitAllStates(state: StoresSnapshot) {\r\n    for (const [store, committedState] of state) {\r\n      store.commit(committedState);\r\n    }\r\n    this.sweep();\r\n  }\r\n\r\n  removeStore(store: Store<any, any>) {\r\n    const prev = this._storeRefCounts.get(store);\r\n    if (prev == null) {\r\n      throw new Error(\r\n        \"Imblance in concurrent-safe store reference counting. This is a bug in react-use-store, please report it.\",\r\n      );\r\n    }\r\n    // We decrement the count here, but don't actually do the cleanup.  This is\r\n    // because a state update could cause the last store subscriber to unmount\r\n    // while also mounting a new subscriber. In this case we need to ensure we\r\n    // don't lose the currently commited state in the moment between when the\r\n    // clean-up of the unmounting component is run and the useLayoutEffect of\r\n    // the mounting component is run.\r\n\r\n    // So, we cleanup unreferenced stores after each commit.\r\n    this._storeRefCounts.set(store, {\r\n      unsubscribe: prev.unsubscribe,\r\n      count: prev.count - 1,\r\n    });\r\n  }\r\n\r\n  sweep() {\r\n    for (const [store, refs] of this._storeRefCounts) {\r\n      if (refs.count < 1) {\r\n        refs.unsubscribe();\r\n        this._storeRefCounts.delete(store);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { useEffect, useState, useTransition } from \"react\";\r\nimport { REACT_STORE_TYPE, ReactStore } from \"./types\";\r\n\r\ntype Store<Value, Action = Value> = ReactStore<Value, Action> & {\r\n  $$typeof: typeof REACT_STORE_TYPE;\r\n  _listeners: Set<() => void>;\r\n  _current: Value;\r\n  _sync: Value;\r\n  _transition: Value;\r\n  subscribe: (listener: () => void) => () => void;\r\n  refresh: () => void;\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst isStore = <Value>(value: any): value is Store<Value, any> => {\r\n  return value && \"$$typeof\" in value && value.$$typeof === REACT_STORE_TYPE;\r\n};\r\n\r\nexport function createStore<Value>(\r\n  initialValue: Value,\r\n): ReactStore<Value, Value>;\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nexport function createStore<Value, Action>(\r\n  initialValue: Value,\r\n  reducer: (currentValue: Value) => Value,\r\n): ReactStore<Value, void>;\r\n\r\nexport function createStore<Value, Action>(\r\n  initialValue: Value,\r\n  reducer: (currentValue: Value, action: Action) => Value,\r\n): ReactStore<Value, Action>;\r\n\r\nexport function createStore<Value, Action>(\r\n  initialValue: Value,\r\n  reducer?: (currentValue: Value, action: Action) => Value,\r\n): ReactStore<Value, Action> {\r\n  const store: Store<Value, Action> = {\r\n    $$typeof: REACT_STORE_TYPE,\r\n    _listeners: new Set(),\r\n    _current: initialValue,\r\n    _sync: initialValue,\r\n    _transition: initialValue,\r\n    refresh: () => {\r\n      store._listeners.forEach((listener) => listener());\r\n    },\r\n    subscribe: (listener) => {\r\n      store._listeners.add(listener);\r\n      return () => {\r\n        store._listeners.delete(listener);\r\n      };\r\n    },\r\n    update: (action: Action) => {\r\n      store._transition = reducer\r\n        ? reducer(store._transition, action)\r\n        : (action as unknown as Value);\r\n      store.refresh();\r\n    },\r\n  };\r\n\r\n  return store;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport function useStore<Value>(store: ReactStore<Value, any>): Value {\r\n  if (!isStore<Value>(store)) {\r\n    throw new Error(\r\n      \"Invalid store type. Ensure you are using a valid React store.\",\r\n    );\r\n  }\r\n\r\n  const [cache, setCache] = useState(() => store._current);\r\n  const [_, startTransition] = useTransition();\r\n\r\n  useEffect(() => {\r\n    return store.subscribe(() => {\r\n      store._sync = store._transition;\r\n      startTransition(() => {\r\n        setCache((store._current = store._sync));\r\n      });\r\n    });\r\n  }, [store]);\r\n\r\n  return cache;\r\n}\r\n","export const REACT_STORE_TYPE: symbol = Symbol.for(\"react.store\");\r\n\r\nexport type ReactStore<Value, Action = Value> = {\r\n  [REACT_STORE_TYPE]: never;\r\n  update: (action: Action) => void;\r\n};\r\n\r\n/**\r\n * Represents a data source which can be connected to React by wrapping it as a\r\n * React Store\r\n */\r\nexport interface ISource<S, A> {\r\n  /**\r\n   * Returns an immutable snapshot of the current state\r\n   */\r\n  getState(): S;\r\n  /**\r\n   * A pure function which takes and arbitrary state and an updater/action and\r\n   * returns a new state.\r\n   *\r\n   * React needs this in order to generate temporary states.\r\n   *\r\n   * See: https://jordaneldredge.com/notes/react-rebasing/\r\n   */\r\n  reducer: Reducer<S, A>;\r\n}\r\n\r\nexport type Reducer<S, A> = (state: S, action: A) => S;\r\n","export type { ReactStore, ISource, Reducer } from \"./types\";\r\nimport * as Experimental from \"./experimental\";\r\n\r\nexport { createStore, useStore } from \"./useStore\";\r\n\r\n// Until we update the docs, we export the new API under the name `experimental`\r\nexport const experimental = Experimental;\r\n"],"mappings":"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","names":["startTransition","allStates","startTransition","state","useEffect","useState","createStore","useStore","useState","startTransition","useEffect"]}