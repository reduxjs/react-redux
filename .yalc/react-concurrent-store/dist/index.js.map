{"version":3,"sources":["../src/experimental/index.ts","../src/experimental/useStore.tsx","../src/experimental/Store.ts","../src/experimental/Emitter.ts","../src/experimental/StoreManager.ts","../src/useStore.ts","../src/types.ts","../src/index.ts"],"sourcesContent":["export {\r\n  useStore,\r\n  useStoreSelector,\r\n  useStoreSelectorWithEquality,\r\n  createStore,\r\n  createStoreFromSource,\r\n  StoreProvider,\r\n} from \"./useStore\";\r\n\r\n// Export types needed for public API\r\nexport type { ISource, Reducer } from \"../types\";\r\nexport type { ReactStore } from \"./Store\";\r\nexport { Store } from \"./Store\";\r\n","import * as React from \"react\";\r\nimport {\r\n  createContext,\r\n  memo,\r\n  startTransition,\r\n  useContext,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n  useDebugValue,\r\n} from \"react\";\r\nimport { Store } from \"./Store\";\r\nimport { ISource, Reducer } from \"../types\";\r\nimport { StoreManager } from \"./StoreManager\";\r\n\r\n/**\r\n * Concurrent-Safe Store\r\n *\r\n * The store and a associated hook ensures that when new store readers mount,\r\n * they will observe the same state as all other components currently mounted,\r\n * even if the store's state is currently updating within a slow transition.\r\n *\r\n * They further ensure that React's rebasing rules apply to state observed via\r\n * these hooks. Specifically, updates always apply in the order in chronological\r\n * order. This means that if a sync update to the store is triggered while a\r\n * transition update to the store is still pending that sync update will apply\r\n * on top of the pre-transition state (as if the transition update had not yet\r\n * happened), but when the transition resolves it will reflect the chronological\r\n * ordering of: initial, transition, sync.\r\n *\r\n * Note: Rather than expose generic versions of these hooks/providers and have them\r\n * read the store via context, we use a factory function which returns pre-bound\r\n * functions. This has the advantage of producing typed variants of the hooks.\r\n *\r\n * A more standard context based solution should also be possible.\r\n */\r\nexport function createStore<S, A>(\r\n  reducer: Reducer<S, A>,\r\n  initialState: S,\r\n): Store<S, A> & { dispatch: (action: A) => void } {\r\n  let state = initialState;\r\n  const store = new Store<S, A>({\r\n    getState: () => state,\r\n    reducer,\r\n  });\r\n\r\n  // @ts-expect-error TODO: Fix typing\r\n  store.dispatch = (action: A) => {\r\n    state = reducer(state, action);\r\n    store.handleUpdate(action);\r\n  };\r\n  // @ts-expect-error TODO: Fix typing\r\n  return store;\r\n}\r\n\r\nexport function createStoreFromSource<S, A>(\r\n  source: ISource<S, A>,\r\n): Store<S, A> {\r\n  return new Store<S, A>(source);\r\n}\r\n\r\nconst storeManagerContext = createContext<StoreManager | null>(null);\r\n\r\n/**\r\n * An awkward kludge which attempts to signal back to the stores when a\r\n * transition containing store updates has been committed to the React tree.\r\n */\r\nconst CommitTracker = memo(\r\n  ({ storeManager }: { storeManager: StoreManager }) => {\r\n    const [allStates, setAllStates] = useState(\r\n      storeManager.getAllCommittedStates(),\r\n    );\r\n    useEffect(() => {\r\n      const unsubscribe = storeManager.subscribe(() => {\r\n        const allStates = storeManager.getAllStates();\r\n        setAllStates(allStates);\r\n      });\r\n      return () => {\r\n        unsubscribe();\r\n        storeManager.sweep();\r\n      };\r\n    }, [storeManager]);\r\n\r\n    useLayoutEffect(() => {\r\n      storeManager.commitAllStates(allStates);\r\n    }, [storeManager, allStates]);\r\n    return null;\r\n  },\r\n);\r\n\r\n/**\r\n * A single provider which tracks commits for all stores being read in the tree.\r\n */\r\nexport function StoreProvider({ children }: { children: React.ReactNode }) {\r\n  const [storeManager] = useState(() => new StoreManager());\r\n  return (\r\n    <storeManagerContext.Provider value={storeManager}>\r\n      <CommitTracker storeManager={storeManager} />\r\n      {children}\r\n    </storeManagerContext.Provider>\r\n  );\r\n}\r\n\r\ntype HookState<S, T> = {\r\n  value: T;\r\n  selector: (state: S, prevResult?: T) => T;\r\n};\r\n\r\n/**\r\n * Tearing-resistant hook for consuming application state locally within a\r\n * component (without prop drilling or putting state in context).\r\n *\r\n * Attempts to avoid the failure mode where the application state is updating as\r\n * part of a transition and a sync state change causes a new component to mount\r\n * that reads the application state.\r\n *\r\n * A naive implementation which simply subscribes to state changes in a useEffect\r\n * would incorrectly mount using the pending state causing tearing between the\r\n * newly mounted component (showing the new state) and the previously mounted\r\n * components which would still be showing the old state.\r\n *\r\n * A slightly more sophisticated approach which mounts with the currently\r\n * committed state would suffer from permanent tearing since the mount state\r\n * would not update to the pending state along with the rest of the\r\n * pending transition.\r\n *\r\n * This approach mounts with the currently committed state and then, if needed\r\n * schedules a \"fixup\" update inside a transition to ensure the newly mounted\r\n * component updates along with any other components that are part of the\r\n * current pending transition.\r\n *\r\n * This implementation also attempts to solve for a non-concurrent race\r\n * condition where state updates between initial render and when the\r\n * `useEffect` mounts. e.g. in the `useEffect` of another component that gets\r\n * mounted before this one. Here the risk is that we miss the update, since we\r\n * are not subscribed yet, and end up rendering the stale state with no update\r\n * scheduled to catch us up with the rest of the app.\r\n */\r\nexport function useStoreSelector<S, T>(\r\n  store: Store<S, never>,\r\n  selector: (state: S, prevResult?: T) => T,\r\n): T {\r\n  const storeManager = useContext(storeManagerContext);\r\n  if (storeManager == null) {\r\n    throw new Error(\r\n      \"Expected useStoreSelector to be rendered within a StoreProvider.\",\r\n    );\r\n  }\r\n  const previousStoreRef = useRef(store);\r\n  if (store !== previousStoreRef.current) {\r\n    throw new Error(\r\n      \"useStoreSelector does not currently support dynamic stores\",\r\n    );\r\n  }\r\n\r\n  // Counterintuitively we initially render with the transition/head state\r\n  // instead of the committed state. This is required in order for us to\r\n  // handle the case where we mount as part of a transition which is actively\r\n  // changing the state we observe. In that case, if we _don't_ mount with the\r\n  // transition state, there's no place where we can schedule a fixup which\r\n  // will get entangled with the transition that is rendering us. React forces\r\n  // all setStates fired during render into their own lane, and by the time\r\n  // our useLayoutEffect fires, the transition will already be completed.\r\n  //\r\n  // Instead we must initially render with the transition state and then\r\n  // trigger a sync fixup setState in the useLayoutEffect if we are mounting\r\n  // sync and thus should be showing the committed state.\r\n  //\r\n  // We also track the selector used for each state so that we can determine if\r\n  // the selector has changed since our last updated.\r\n  const [hookState, setState] = useState<HookState<S, T>>(() => ({\r\n    value: selector(store.getState(), undefined),\r\n    selector,\r\n  }));\r\n\r\n  // If we have a new selector, we try to derive a new value during render. If\r\n  // the mount was sync, we'll apply a fixup in useLayoutEffect, just like we do\r\n  // on mount.\r\n  const selectorChange = hookState.selector !== selector;\r\n  const state = selectorChange\r\n    ? selector(store.getState(), hookState.value)\r\n    : hookState.value;\r\n\r\n  useLayoutEffect(() => {\r\n    // Ensure our store is managed by the tracker.\r\n    storeManager.addStore(store);\r\n    const mountState = selector(store.getState(), hookState.value);\r\n    const mountCommittedState = selector(\r\n      store.getCommittedState(),\r\n      hookState.value,\r\n    );\r\n\r\n    // Helper to ensure we preserve object identity if neither state nor selector has changed.\r\n    function setHookState(value: T) {\r\n      setState((prev) => {\r\n        // If nothing has changed...\r\n        if (is(prev.value, value) && prev.selector === selector) {\r\n          // Preserve object identity.\r\n          return prev;\r\n        }\r\n        return { value, selector };\r\n      });\r\n    }\r\n\r\n    // If we are mounting as part of a sync update mid transition, our initial\r\n    // render value was wrong and we must trigger a sync fixup update.\r\n    // Similarly, if a sync state update was triggered between the moment we\r\n    // rendered and now (e.g. in some sibling component's useLayoutEffect) we\r\n    // need to trigger a fixup.\r\n    //\r\n    // Both of these cases manifest as our initial render state not matching\r\n    // the currently committed state.\r\n    if (state !== mountCommittedState) {\r\n      setHookState(mountCommittedState);\r\n    }\r\n\r\n    // If we mounted mid-transition, and that transition is still ongoing, we\r\n    // just triggered a fixup to switch bath to the pre-transition, comitted,\r\n    // state but are not ourselves part of the. We must ensure we _also_ still\r\n    // update back to the transitions state along with the rest of the UI when\r\n    // the transition resolves\r\n    //\r\n    // It's also possible that between the time when we rendered and now, a new\r\n    // transition update has started. For example, a `startTransition` in a\r\n    // `useLayoutEffect` of a earlier sibling component. In that case we want to\r\n    // add ourselves to that transition.\r\n    if (mountState !== mountCommittedState) {\r\n      // Here we tell React to update us to the new pending state. Since there\r\n      // is a difference between the canonical state and the comitted state, we\r\n      // assume there is a transition currently happening, and (unsafely) depend\r\n      // upon current transition entanglement semantics which we expect\r\n      // will ensure this update gets added to the currently pending\r\n      // transition. Our goal is that when the transition that was pending\r\n      // while we were mounting resolves, it will also include rerendering\r\n      // this component to reflect the new state.\r\n      startTransition(() => {\r\n        setHookState(mountState);\r\n      });\r\n    }\r\n\r\n    const unsubscribe = store.subscribe(() => {\r\n      // Capture store state eagerly when subscription fires, not when React processes the update\r\n      const currentStoreState = store.getState();\r\n      setState((prev) => {\r\n        const newValue = selector(currentStoreState, prev.value);\r\n        // Preserve object identity if neither value nor selector changed - critical for React bailout\r\n        if (is(prev.value, newValue) && prev.selector === selector) {\r\n          return prev;\r\n        }\r\n        return { value: newValue, selector };\r\n      });\r\n    });\r\n    return () => {\r\n      unsubscribe();\r\n      storeManager.removeStore(store);\r\n    };\r\n    // We intentionally ignore `state` since we only care about its value on\r\n    // mount or when the selector changes.\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [selector]);\r\n\r\n  return state;\r\n}\r\n\r\nfunction identity<T>(x: T): T {\r\n  return x;\r\n}\r\n\r\nexport function useStore<S>(store: Store<S, never>): S {\r\n  return useStoreSelector(store, identity);\r\n}\r\n\r\nfunction is(x: unknown, y: unknown) {\r\n  if (x === y) {\r\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\r\n  } else {\r\n    return x !== x && y !== y;\r\n  }\r\n}\r\n\r\nexport function useStoreSelectorWithEquality<State, Selection>(\r\n  store: Store<State, never>,\r\n  selector: (state: State) => Selection,\r\n  isEqual: (a: Selection, b: Selection) => boolean = Object.is,\r\n): Selection {\r\n  const memoizedSelector = useMemo(() => {\r\n    // Track the memoized state using closure variables that are local to this\r\n    // memoized instance of a getSnapshot function. Intentionally not using a\r\n    // useRef hook, because that state would be shared across all concurrent\r\n    // copies of the hook/component.\r\n    let hasMemo = false;\r\n    let memoizedSnapshot: State;\r\n    let memoizedSelection: Selection;\r\n\r\n    const memoizedSelector = (nextSnapshot: State, prevResult?: Selection) => {\r\n      if (!hasMemo) {\r\n        // The first time the hook is called, there is no memoized result.\r\n        hasMemo = true;\r\n        memoizedSnapshot = nextSnapshot;\r\n        const nextSelection = selector(nextSnapshot);\r\n        // Even if the selector has changed, the currently rendered selection\r\n        // may be equal to the new selection. We should attempt to reuse the\r\n        // current value if possible, to preserve downstream memoizations.\r\n        if (prevResult !== undefined && isEqual(prevResult, nextSelection)) {\r\n          memoizedSelection = prevResult;\r\n          return prevResult;\r\n        }\r\n        memoizedSelection = nextSelection;\r\n        return nextSelection;\r\n      }\r\n\r\n      // We may be able to reuse the previous invocation's result.\r\n      const prevSnapshot = memoizedSnapshot;\r\n      const prevSelection = memoizedSelection;\r\n\r\n      if (is(prevSnapshot, nextSnapshot)) {\r\n        // The snapshot is the same as last time. Reuse the previous selection.\r\n        return prevSelection;\r\n      }\r\n\r\n      // The snapshot has changed, so we need to compute a new selection.\r\n      const nextSelection = selector(nextSnapshot);\r\n\r\n      // If a custom isEqual function is provided, use that to check if the data\r\n      // has changed. If it hasn't, return the previous selection. That signals\r\n      // to React that the selections are conceptually equal, and we can bail\r\n      // out of rendering.\r\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\r\n        // The snapshot still has changed, so make sure to update to not keep\r\n        // old references alive\r\n        memoizedSnapshot = nextSnapshot;\r\n        return prevSelection;\r\n      }\r\n\r\n      memoizedSnapshot = nextSnapshot;\r\n      memoizedSelection = nextSelection;\r\n      return nextSelection;\r\n    };\r\n\r\n    return memoizedSelector;\r\n  }, [selector, isEqual]);\r\n\r\n  const value = useStoreSelector(store, memoizedSelector);\r\n\r\n  useDebugValue(value);\r\n  return value;\r\n}\r\n","import * as React from \"react\";\r\nimport { startTransition } from \"react\";\r\nimport { ISource } from \"../types\";\r\nimport Emitter from \"./Emitter\";\r\n\r\nconst sharedReactInternals: { T: unknown } =\r\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE as any;\r\n\r\nfunction reactTransitionIsActive() {\r\n  return !!sharedReactInternals.T;\r\n}\r\n\r\nexport interface ReactStore<S, A = never> {\r\n  getState(): S;\r\n  getCommittedState(): S;\r\n  handleUpdate(action: A): void;\r\n  subscribe(listener: () => void): () => void;\r\n  commit(state: S): void;\r\n}\r\n\r\nexport class Store<S, A> extends Emitter<[]> implements ReactStore<S, A> {\r\n  source: ISource<S, A>;\r\n  state: S;\r\n  committedState: S;\r\n  constructor(source: ISource<S, A>) {\r\n    super();\r\n    this.source = source;\r\n    this.state = source.getState();\r\n    this.committedState = source.getState();\r\n  }\r\n\r\n  commit(state: S) {\r\n    this.committedState = state;\r\n  }\r\n  getCommittedState(): S {\r\n    return this.committedState;\r\n  }\r\n  getState(): S {\r\n    return this.state;\r\n  }\r\n  handleUpdate(action: A) {\r\n    const noPendingTransitions = this.committedState === this.state;\r\n\r\n    this.state = this.source.getState();\r\n\r\n    if (reactTransitionIsActive()) {\r\n      // For transition updates, everything is simple. Just notify all readers\r\n      // of the new state.\r\n      this.notify();\r\n    } else {\r\n      // For sync updates, we must consider if we need to juggle multiple state\r\n      // updates.\r\n\r\n      // If there are no pending transition updates, things are very similar to\r\n      // a transition update except that we can proactively mark the new state\r\n      // as committed.\r\n      if (noPendingTransitions) {\r\n        this.committedState = this.state;\r\n        this.notify();\r\n      } else {\r\n        // If there are pending transition updates, we must ensure we compute\r\n        // an additional new states: This update applied on top of the current\r\n        // committed state.\r\n\r\n        const newState = this.state;\r\n\r\n        // React's rebasing semantics mean readers will expect to see this\r\n        // update applied on top of the currently committed state sync.\r\n        this.committedState = this.source.reducer(this.committedState, action);\r\n        // Temporarily set the state so that readers during this notify read the\r\n        // new committed state.\r\n        this.state = this.committedState;\r\n        this.notify();\r\n\r\n        // Now that we've triggered the sync updates, we need to ensure the\r\n        // pending transition update now goes to the correct new state. We reset\r\n        // the state to point to the new transition state and trigger a set of\r\n        // updates inside a transition.\r\n\r\n        // With existing transition semantics this should result in these\r\n        // updates entangling with the previous transition and that transition\r\n        // will now include this state instead of the previously pending state.\r\n        this.state = newState;\r\n        startTransition(() => {\r\n          this.notify();\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n","export default class Emitter<T extends Array<unknown>> {\r\n  _listeners: Array<(...value: T) => void> = [];\r\n  subscribe(cb: (...value: T) => void): () => void {\r\n    const wrapped = (...value: T) => cb(...value);\r\n    this._listeners.push(wrapped);\r\n    return () => {\r\n      this._listeners = this._listeners.filter((s) => s !== wrapped);\r\n    };\r\n  }\r\n  notify(...value: T) {\r\n    this._listeners.forEach((cb) => {\r\n      cb(...value);\r\n    });\r\n  }\r\n}\r\n","import Emitter from \"./Emitter\";\r\nimport { Store } from \"./Store\";\r\n\r\ntype RefCountedSubscription = {\r\n  count: number;\r\n  unsubscribe: () => void;\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\ntype AnyStore = Store<any, never>;\r\n\r\ntype StoresSnapshot = Map<AnyStore, unknown>;\r\n\r\n/**\r\n * StoreManager tracks all actively rendered stores in the tree and maintains a\r\n * reference-counted subscription to each one. This allows the <CommitTracker />\r\n * component to observe every state update and record each store's committed\r\n * state.\r\n */\r\nexport class StoreManager extends Emitter<[]> {\r\n  _storeRefCounts: Map<AnyStore, RefCountedSubscription> = new Map();\r\n\r\n  getAllCommittedStates(): StoresSnapshot {\r\n    return new Map(\r\n      Array.from(this._storeRefCounts.keys()).map((store) => [\r\n        store,\r\n        store.getCommittedState(),\r\n      ]),\r\n    );\r\n  }\r\n\r\n  getAllStates(): StoresSnapshot {\r\n    return new Map(\r\n      Array.from(this._storeRefCounts.keys()).map((store) => [\r\n        store,\r\n        store.getState(),\r\n      ]),\r\n    );\r\n  }\r\n\r\n  addStore(store: AnyStore) {\r\n    const prev = this._storeRefCounts.get(store);\r\n    if (prev == null) {\r\n      this._storeRefCounts.set(store, {\r\n        unsubscribe: store.subscribe(() => {\r\n          this.notify();\r\n        }),\r\n        count: 1,\r\n      });\r\n    } else {\r\n      this._storeRefCounts.set(store, { ...prev, count: prev.count + 1 });\r\n    }\r\n  }\r\n\r\n  commitAllStates(state: StoresSnapshot) {\r\n    for (const [store, committedState] of state) {\r\n      store.commit(committedState);\r\n    }\r\n    this.sweep();\r\n  }\r\n\r\n  removeStore(store: AnyStore) {\r\n    const prev = this._storeRefCounts.get(store);\r\n    if (prev == null) {\r\n      throw new Error(\r\n        \"Imbalance in concurrent-safe store reference counting. This is a bug in react-use-store, please report it.\",\r\n      );\r\n    }\r\n    // We decrement the count here, but don't actually do the cleanup.  This is\r\n    // because a state update could cause the last store subscriber to unmount\r\n    // while also mounting a new subscriber. In this case we need to ensure we\r\n    // don't lose the currently commited state in the moment between when the\r\n    // clean-up of the unmounting component is run and the useLayoutEffect of\r\n    // the mounting component is run.\r\n\r\n    // So, we cleanup unreferenced stores after each commit.\r\n    this._storeRefCounts.set(store, {\r\n      unsubscribe: prev.unsubscribe,\r\n      count: prev.count - 1,\r\n    });\r\n  }\r\n\r\n  sweep() {\r\n    for (const [store, refs] of this._storeRefCounts) {\r\n      if (refs.count < 1) {\r\n        refs.unsubscribe();\r\n        this._storeRefCounts.delete(store);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { useEffect, useState, useTransition } from \"react\";\r\nimport { REACT_STORE_TYPE, ReactStore } from \"./types\";\r\n\r\ntype Store<Value, Action = Value> = ReactStore<Value, Action> & {\r\n  $$typeof: typeof REACT_STORE_TYPE;\r\n  _listeners: Set<() => void>;\r\n  _current: Value;\r\n  _sync: Value;\r\n  _transition: Value;\r\n  subscribe: (listener: () => void) => () => void;\r\n  refresh: () => void;\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst isStore = <Value>(value: any): value is Store<Value, any> => {\r\n  return value && \"$$typeof\" in value && value.$$typeof === REACT_STORE_TYPE;\r\n};\r\n\r\nexport function createStore<Value>(\r\n  initialValue: Value,\r\n): ReactStore<Value, Value>;\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nexport function createStore<Value, Action>(\r\n  initialValue: Value,\r\n  reducer: (currentValue: Value) => Value,\r\n): ReactStore<Value, void>;\r\n\r\nexport function createStore<Value, Action>(\r\n  initialValue: Value,\r\n  reducer: (currentValue: Value, action: Action) => Value,\r\n): ReactStore<Value, Action>;\r\n\r\nexport function createStore<Value, Action>(\r\n  initialValue: Value,\r\n  reducer?: (currentValue: Value, action: Action) => Value,\r\n): ReactStore<Value, Action> {\r\n  const store: Store<Value, Action> = {\r\n    $$typeof: REACT_STORE_TYPE,\r\n    _listeners: new Set(),\r\n    _current: initialValue,\r\n    _sync: initialValue,\r\n    _transition: initialValue,\r\n    refresh: () => {\r\n      store._listeners.forEach((listener) => listener());\r\n    },\r\n    subscribe: (listener) => {\r\n      store._listeners.add(listener);\r\n      return () => {\r\n        store._listeners.delete(listener);\r\n      };\r\n    },\r\n    update: (action: Action) => {\r\n      store._transition = reducer\r\n        ? reducer(store._transition, action)\r\n        : (action as unknown as Value);\r\n      store.refresh();\r\n    },\r\n  };\r\n\r\n  return store;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport function useStore<Value>(store: ReactStore<Value, any>): Value {\r\n  if (!isStore<Value>(store)) {\r\n    throw new Error(\r\n      \"Invalid store type. Ensure you are using a valid React store.\",\r\n    );\r\n  }\r\n\r\n  const [cache, setCache] = useState(() => store._current);\r\n  const [_, startTransition] = useTransition();\r\n\r\n  useEffect(() => {\r\n    return store.subscribe(() => {\r\n      store._sync = store._transition;\r\n      startTransition(() => {\r\n        setCache((store._current = store._sync));\r\n      });\r\n    });\r\n  }, [store]);\r\n\r\n  return cache;\r\n}\r\n","export const REACT_STORE_TYPE: symbol = Symbol.for(\"react.store\");\r\n\r\nexport type ReactStore<Value, Action = Value> = {\r\n  [REACT_STORE_TYPE]: never;\r\n  update: (action: Action) => void;\r\n};\r\n\r\n/**\r\n * Represents a data source which can be connected to React by wrapping it as a\r\n * React Store\r\n */\r\nexport interface ISource<S, A> {\r\n  /**\r\n   * Returns an immutable snapshot of the current state\r\n   */\r\n  getState(): S;\r\n  /**\r\n   * A pure function which takes and arbitrary state and an updater/action and\r\n   * returns a new state.\r\n   *\r\n   * React needs this in order to generate temporary states.\r\n   *\r\n   * See: https://jordaneldredge.com/notes/react-rebasing/\r\n   */\r\n  reducer: Reducer<S, A>;\r\n}\r\n\r\nexport type Reducer<S, A> = (state: S, action: A) => S;\r\n","export type { ReactStore, ISource, Reducer } from \"./types\";\r\nimport * as Experimental from \"./experimental\";\r\n\r\nexport { createStore, useStore } from \"./useStore\";\r\n\r\n// Until we update the docs, we export the new API under the name `experimental`\r\nexport const experimental = Experimental;\r\n"],"mappings":"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","names":["startTransition","allStates","startTransition","memoizedSelector","nextSelection","useEffect","useState","createStore","useStore","useState","startTransition","useEffect"]}